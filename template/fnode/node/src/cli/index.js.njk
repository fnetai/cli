{% if atom.doc.features.cli.enabled===true %}

{% if atom.doc.features.project.format==='esm' %}

import argv from '../default/input.args.js';

{% if atom.doc.features.cli.extend===true %}

import Node from '../../../cli';

{% if atom.doc.features.cli.mcp.enabled===true %}
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
// Using Node.js built-in http module instead of express
{% endif %}

const run = async () => {
  const args = await argv();
  const cliMode = args['cli-mode'] || args.cli_mode || 'default';

  if (cliMode === 'default') {
    // Default mode code
    return await Node(args);
  }

  {% if atom.doc.features.cli.mcp.enabled===true %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new McpServer({
      name: "{{atom.doc.name}}",
      version: "{{atom.doc.version}}"
    });

    server.tool(
      "{{atom.doc.name}}",
      async (toolArgs) => {
        try {
          const result = await Node(toolArgs);
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
    );

    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.log("MCP server started with stdio transport");
    return;
  }
  {% endif %}

  {% if atom.doc.features.cli.http.enabled===true %}
  if (cliMode === 'http') {
    // HTTP mode code using built-in http module
    const http = require('http');

    const server = http.createServer((req, res) => {
      if (req.method === 'POST' && req.url === '/{{atom.doc.name}}') {
        let body = '';
        req.on('data', chunk => {
          body += chunk.toString();
        });
        req.on('end', async () => {
          try {
            const data = JSON.parse(body);
            const result = await Node(data);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(result));
          } catch (error) {
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: error.message }));
          }
        });
      } else {
        res.writeHead(404);
        res.end();
      }
    });

    const port = args['cli-port'] || args.cli_port || 3000;
    server.listen(port, () => {
      console.log(`HTTP server started on port ${port}`);
    });
    return;
  }
  {% endif %}

  console.error(`Unknown CLI mode: ${cliMode}`);
  process.exit(1);
};

run()
  .then(() => {
    {# process.exit(0);     #}
  })
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });

{% else %}
import Node from '../../../src';

{% if atom.doc.features.cli.mcp.enabled===true %}
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
import express from 'express';
{% endif %}

const run = async () => {
  const args = await argv();
  const cliMode = args['cli-mode'] || args.cli_mode || 'default';

  if (cliMode === 'default') {
    // Default mode code
    const result = await Node(args);

    if (typeof result !== 'undefined') {
      const stdout_format = args['stdout-format'] || args.stdout_format || null;

      if (stdout_format === 'json') console.log(JSON.stringify(result, null, 2));
      else console.log(result);
    }
    return;
  }

  {% if atom.doc.features.cli.mcp.enabled===true %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new McpServer({
      name: "{{atom.doc.name}}",
      version: "{{atom.doc.version}}"
    });

    server.tool(
      "{{atom.doc.name}}",
      async (toolArgs) => {
        try {
          const result = await Node(toolArgs);
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
    );

    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.log("MCP server started with stdio transport");
    return;
  }
  {% endif %}

  {% if atom.doc.features.cli.http.enabled===true %}
  if (cliMode === 'http') {
    // HTTP mode code
    const app = express();
    app.use(express.json());

    app.post('/{{atom.doc.name}}', async (req, res) => {
      try {
        const result = await Node(req.body);
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    const port = args['cli-port'] || args.cli_port || 3000;
    app.listen(port, () => {
      console.log(`HTTP server started on port ${port}`);
    });
    return;
  }
  {% endif %}

  console.error(`Unknown CLI mode: ${cliMode}`);
  process.exit(1);
};

run()
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });
{% endif %}

{% elif atom.doc.features.project.format==='cjs' %}

const argv = require('../default/input.args.js');

{% if atom.doc.features.cli.extend===true %}

const Node = require('../../../cli');

{% if atom.doc.features.cli.mcp.enabled===true %}
const { McpServer } = require("@modelcontextprotocol/sdk/server/mcp.js");
const { StdioServerTransport } = require("@modelcontextprotocol/sdk/server/stdio.js");
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
// Using Node.js built-in http module instead of express
{% endif %}

const run = async () => {
  const args = await argv();
  const cliMode = args['cli-mode'] || args.cli_mode || 'default';

  if (cliMode === 'default') {
    // Default mode code
    return await Node(args);
  }

  {% if atom.doc.features.cli.mcp.enabled===true %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new McpServer({
      name: "{{atom.doc.name}}",
      version: "{{atom.doc.version}}"
    });

    server.tool(
      "{{atom.doc.name}}",
      async (toolArgs) => {
        try {
          const result = await Node(toolArgs);
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
    );

    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.log("MCP server started with stdio transport");
    return;
  }
  {% endif %}

  {% if atom.doc.features.cli.http.enabled===true %}
  if (cliMode === 'http') {
    // HTTP mode code using built-in http module
    const http = require('http');

    const server = http.createServer((req, res) => {
      if (req.method === 'POST' && req.url === '/{{atom.doc.name}}') {
        let body = '';
        req.on('data', chunk => {
          body += chunk.toString();
        });
        req.on('end', async () => {
          try {
            const data = JSON.parse(body);
            const result = await Node(data);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(result));
          } catch (error) {
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: error.message }));
          }
        });
      } else {
        res.writeHead(404);
        res.end();
      }
    });

    const port = args['cli-port'] || args.cli_port || 3000;
    server.listen(port, () => {
      console.log(`HTTP server started on port ${port}`);
    });
    return;
  }
  {% endif %}

  console.error(`Unknown CLI mode: ${cliMode}`);
  process.exit(1);
};

run()
  .then(() => {
    {# process.exit(0); #}
  })
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });

{% else %}
const Node = require('../../../src');

{% if atom.doc.features.cli.mcp.enabled===true %}
const { McpServer } = require("@modelcontextprotocol/sdk/server/mcp.js");
const { StdioServerTransport } = require("@modelcontextprotocol/sdk/server/stdio.js");
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
// Using Node.js built-in http module instead of express
{% endif %}

const run = async () => {
  const args = await argv();
  const cliMode = args['cli-mode'] || args.cli_mode || 'default';

  if (cliMode === 'default') {
    // Default mode code
    const result = await Node(args);

    if (typeof result !== 'undefined') {
      const stdout_format = args['stdout-format'] || args.stdout_format || null;

      if (stdout_format === 'json') console.log(JSON.stringify(result, null, 2));
      else console.log(result);
    }
    return;
  }

  {% if atom.doc.features.cli.mcp.enabled===true %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new McpServer({
      name: "{{atom.doc.name}}",
      version: "{{atom.doc.version}}"
    });

    server.tool(
      "{{atom.doc.name}}",
      async (toolArgs) => {
        try {
          const result = await Node(toolArgs);
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
    );

    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.log("MCP server started with stdio transport");
    return;
  }
  {% endif %}

  {% if atom.doc.features.cli.http.enabled===true %}
  if (cliMode === 'http') {
    // HTTP mode code using built-in http module
    const http = require('http');

    const server = http.createServer((req, res) => {
      if (req.method === 'POST' && req.url === '/{{atom.doc.name}}') {
        let body = '';
        req.on('data', chunk => {
          body += chunk.toString();
        });
        req.on('end', async () => {
          try {
            const data = JSON.parse(body);
            const result = await Node(data);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(result));
          } catch (error) {
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: error.message }));
          }
        });
      } else {
        res.writeHead(404);
        res.end();
      }
    });

    const port = args['cli-port'] || args.cli_port || 3000;
    server.listen(port, () => {
      console.log(`HTTP server started on port ${port}`);
    });
    return;
  }
  {% endif %}

  console.error(`Unknown CLI mode: ${cliMode}`);
  process.exit(1);
};

run()
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });
{% endif %}

{% endif %}

{% endif %}