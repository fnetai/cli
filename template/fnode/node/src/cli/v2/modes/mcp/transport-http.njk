{# ============================================================================
   MCP MODE - HTTP TRANSPORT
   ============================================================================
   Streamable HTTP transport for MCP protocol with session management
   Official transport as of MCP 2025-03-26
   ============================================================================ #}

// Use Streamable HTTP transport (official transport as of MCP 2025-03-26)
const app = express();
app.use(express.json());

const port = args['cli-port'] || args.cli_port || 3000;
const host = args['cli-host'] || args.cli_host || '0.0.0.0';
const mcpEndpoint = '/mcp';
const verbose = args['cli-verbose'] || args.cli_verbose || false;

// Verbose logging helper
const log = (...args) => {
  if (verbose) {
    console.log('[MCP]', new Date().toISOString(), ...args);
  }
};

// Map to store transports by session ID
const transports = {};

// Handle POST requests for client-to-server communication
app.post(mcpEndpoint, async (req, res) => {
  // Check for existing session ID
  const sessionId = req.get('Mcp-Session-Id');

  log('POST request received');
  log('Session ID:', sessionId || 'none');
  log('Request body:', JSON.stringify(req.body, null, 2));

  let transport;

  if (sessionId && transports[sessionId]) {
    // Reuse existing transport
    log('Reusing existing transport for session:', sessionId);
    transport = transports[sessionId];
  } else if (!sessionId && req.body && (req.body.method === 'initialize' ||
            (Array.isArray(req.body) && req.body.some(item => item.method === 'initialize')))) {
    // New initialization request
    log('Creating new transport for initialization');
    transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: () => {
        // Generate cryptographically secure session ID
        return crypto.randomBytes(16).toString('hex');
      },
      onsessioninitialized: (sessionId) => {
        // Store the transport by session ID
        log('Session initialized:', sessionId);
        transports[sessionId] = transport;
      }
    });

    // Clean up transport when closed
    transport.onclose = () => {
      if (transport.sessionId) {
        log('Transport closed, cleaning up session:', transport.sessionId);
        delete transports[transport.sessionId];
      }
    };

    // Connect to the MCP server
    await server.connect(transport);
    log('Server connected to transport');
  } else {
    // Invalid request
    log('Invalid request - no valid session ID');
    return res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32000,
        message: 'Bad Request: No valid session ID provided'
      },
      id: null
    });
  }

  // Handle the request
  log('Handling request with transport');
  await transport.handleRequest(req, res, req.body);
});

// Reusable handler for GET and DELETE requests
const handleSessionRequest = async (req, res) => {
  const sessionId = req.get('Mcp-Session-Id');
  log(`${req.method} request received for session:`, sessionId || 'none');

  if (!sessionId || !transports[sessionId]) {
    log('Invalid or missing session ID');
    return res.status(400).send('Invalid or missing session ID');
  }

  const transport = transports[sessionId];
  log('Handling request with existing transport');
  await transport.handleRequest(req, res);
};

// Handle GET requests for server-to-client notifications via SSE
app.get(mcpEndpoint, handleSessionRequest);

// Handle DELETE requests for session termination
app.delete(mcpEndpoint, handleSessionRequest);

app.listen(port, host, () => {
  console.log(`MCP server started with Streamable HTTP transport`);
  console.log(`Endpoint: http://${host}:${port}${mcpEndpoint}`);
  console.log(`Listening on ${host}:${port}`);
  if (verbose) {
    console.log(`Verbose logging enabled`);
  }
});

return;

