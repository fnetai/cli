{% if atom.doc.features.cli.enabled===true %}
import argv from '../default/to.args.js';
import { default as Engine } from '../default/{{atom.doc.features.cli_default_entry_file or atom.doc.features.main_default_entry_file}}';

{% if atom.doc.features.cli.mcp.enabled===true %}
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
// Using Node.js built-in http module instead of express
{% endif %}

  {% if atom.doc.features.cli.extend===true %}
    {# TYPE 1 #}
    import { default as runExtended } from '../../../cli';

    const run = async () => {
      const args = await argv();
      const cliMode = args['cli-mode'] || args.cli_mode || 'default';

      if (cliMode === 'default') {
        // Default mode code
        return await runExtended(args, { Engine });
      }

      {% if atom.doc.features.cli.mcp.enabled===true %}
      if (cliMode === 'mcp') {
        // MCP mode code
        const server = new McpServer({
          name: "{{atom.doc.name}}",
          version: "{{atom.doc.version}}"
        });

        server.tool(
          "{{atom.doc.name}}",
          async (toolArgs) => {
            try {
              const result = await runExtended(toolArgs, { Engine });
              return {
                content: [{
                  type: "text",
                  text: JSON.stringify(result)
                }]
              };
            } catch (error) {
              return {
                content: [{
                  type: "text",
                  text: `Error: ${error.message}`
                }],
                isError: true
              };
            }
          }
        );

        const transport = new StdioServerTransport();
        await server.connect(transport);
        console.log("MCP server started with stdio transport");
        return;
      }
      {% endif %}

      {% if atom.doc.features.cli.http.enabled===true %}
      if (cliMode === 'http') {
        // HTTP mode code using built-in http module
        const http = require('http');

        const server = http.createServer((req, res) => {
          if (req.method === 'POST' && req.url === '/{{atom.doc.name}}') {
            let body = '';
            req.on('data', chunk => {
              body += chunk.toString();
            });
            req.on('end', async () => {
              try {
                const data = JSON.parse(body);
                const result = await runExtended(data, { Engine });
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify(result));
              } catch (error) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: error.message }));
              }
            });
          } else {
            res.writeHead(404);
            res.end();
          }
        });

        const port = args['cli-port'] || args.cli_port || 3000;
        server.listen(port, () => {
          console.log(`HTTP server started on port ${port}`);
        });
        return;
      }
      {% endif %}

      console.error(`Unknown CLI mode: ${cliMode}`);
      process.exit(1);
    };

    run()
      .then(() => {
        {# process.exit(0);  #}
      })
      .catch((error) => {
        console.error(error.message);
        process.exit(1);
      });
  {% else %}
    {# TYPE 2 #}
    const run = async () => {
      const args = await argv();
      const cliMode = args['cli-mode'] || args.cli_mode || 'default';
      const engine = new Engine();

      if (cliMode === 'default') {
        // Default mode code
        const result = await engine.run(args);

        if (typeof result !== 'undefined') {
          const stdout_format = args['stdout-format'] || args.stdout_format || null;

          if (stdout_format === 'json') console.log(JSON.stringify(result, null, 2));
          else console.log(result);
        }
        return;
      }

      {% if atom.doc.features.cli.mcp.enabled===true %}
      if (cliMode === 'mcp') {
        // MCP mode code
        const server = new McpServer({
          name: "{{atom.doc.name}}",
          version: "{{atom.doc.version}}"
        });

        server.tool(
          "{{atom.doc.name}}",
          async (toolArgs) => {
            try {
              const result = await engine.run(toolArgs);
              return {
                content: [{
                  type: "text",
                  text: JSON.stringify(result)
                }]
              };
            } catch (error) {
              return {
                content: [{
                  type: "text",
                  text: `Error: ${error.message}`
                }],
                isError: true
              };
            }
          }
        );

        // Note: Direct access to workflow nodes is not implemented in this version
        // In a future version, we could expose workflow nodes as separate MCP tools

        const transport = new StdioServerTransport();
        await server.connect(transport);
        console.log("MCP server started with stdio transport");
        return;
      }
      {% endif %}

      {% if atom.doc.features.cli.http.enabled===true %}
      if (cliMode === 'http') {
        // HTTP mode code using built-in http module
        const http = require('http');

        const server = http.createServer((req, res) => {
          if (req.method === 'POST' && req.url === '/{{atom.doc.name}}') {
            let body = '';
            req.on('data', chunk => {
              body += chunk.toString();
            });
            req.on('end', async () => {
              try {
                const data = JSON.parse(body);
                const result = await engine.run(data);
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify(result));
              } catch (error) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: error.message }));
              }
            });
          } else {
            res.writeHead(404);
            res.end();
          }
        });

        // Note: Direct access to workflow nodes is not implemented in this version
        // In a future version, we could expose workflow nodes as separate HTTP endpoints

        const port = args['cli-port'] || args.cli_port || 3000;
        server.listen(port, () => {
          console.log(`HTTP server started on port ${port}`);
        });
        return;
      }
      {% endif %}

      console.error(`Unknown CLI mode: ${cliMode}`);
      process.exit(1);
    };

    run()
      .catch((error) => {
        console.error(error.message);
        process.exit(1);
      });
  {% endif %}
{% endif %}