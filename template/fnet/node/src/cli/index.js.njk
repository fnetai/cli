{% if atom.doc.features.cli.enabled===true %}

{# Define macros for reusable code blocks #}
{% macro importMcpDependencies() %}
import { Server, ListToolsRequestSchema, CallToolRequestSchema } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import express from "express";
{% endmacro %}

{% macro mcpModeCodeExtended(runFn) %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new Server({
      name: "{{atom.doc.features.cli.mcp.name or atom.doc.name}}",
      version: "{{atom.doc.version or '0.0.1'}}"
    }, {
      capabilities: {
        tools: {}
      }
    });

    // Define available tools
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "{{atom.doc.features.cli.mcp.tool.name or atom.doc.name}}",
          description: "{{atom.doc.features.cli.mcp.tool.description or atom.doc.description}}",
          inputSchema: {
            type: "object",
            properties: {},
            additionalProperties: true
          }
        }]
      };
    });

    // Handle tool execution
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "{{atom.doc.features.cli.mcp.tool.name or atom.doc.name}}") {
        try {
          const result = await {{ runFn }}(request.params.arguments, { Engine });
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
      throw new Error("Tool not found");
    });

    // Get transport type from arguments
    const transportType = args['mcp-transport-type'] || args.mcp_transport_type || 'stdio';
    let transport;

    if (transportType === 'stdio') {
      // Use stdio transport
      transport = new StdioServerTransport();
    } else if (transportType === 'http') {
      // Use HTTP transport
      const app = express();
      app.use(express.json());

      const port = args['cli-port'] || args.cli_port || 3000;
      const server = app.listen(port, () => {
        console.log(`MCP server started with HTTP transport on port ${port}`);
      });

      transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: () => Math.random().toString(36).substring(2, 15),
      });

      app.post('/mcp', async (req, res) => {
        await transport.handleRequest(req, res, req.body);
      });

      app.get('/mcp', async (req, res) => {
        await transport.handleRequest(req, res);
      });

      app.delete('/mcp', async (req, res) => {
        await transport.handleRequest(req, res);
      });
    } else {
      console.error(`Unknown MCP transport type: ${transportType}`);
      console.error(`Supported types: stdio, http`);
      process.exit(1);
    }

    await server.connect(transport);
    return;
  }
{% endmacro %}

{% macro mcpModeCodeEngine(engineVar) %}
  if (cliMode === 'mcp') {
    // MCP mode code
    const server = new Server({
      name: "{{atom.doc.features.cli.mcp.name or atom.doc.name}}",
      version: "{{atom.doc.version or '0.0.1'}}"
    }, {
      capabilities: {
        tools: {}
      }
    });

    // Define available tools
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "{{atom.doc.features.cli.mcp.tool.name or atom.doc.name}}",
          description: "{{atom.doc.features.cli.mcp.tool.description or atom.doc.description}}",
          inputSchema: {
            type: "object",
            properties: {},
            additionalProperties: true
          }
        }]
      };
    });

    // Handle tool execution
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "{{atom.doc.features.cli.mcp.tool.name or atom.doc.name}}") {
        try {
          const result = await {{ engineVar }}.run(request.params.arguments);
          return {
            content: [{
              type: "text",
              text: JSON.stringify(result)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Error: ${error.message}`
            }],
            isError: true
          };
        }
      }
      throw new Error("Tool not found");
    });

    // Note: Direct access to workflow nodes is not implemented in this version
    // In a future version, we could expose workflow nodes as separate MCP tools

    // Get transport type from arguments
    const transportType = args['mcp-transport-type'] || args.mcp_transport_type || 'stdio';
    let transport;

    if (transportType === 'stdio') {
      // Use stdio transport
      transport = new StdioServerTransport();
    } else if (transportType === 'http') {
      // Use HTTP transport
      const app = express();
      app.use(express.json());

      const port = args['cli-port'] || args.cli_port || 3000;
      const server = app.listen(port, () => {
        console.log(`MCP server started with HTTP transport on port ${port}`);
      });

      transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: () => Math.random().toString(36).substring(2, 15),
      });

      app.post('/mcp', async (req, res) => {
        await transport.handleRequest(req, res, req.body);
      });

      app.get('/mcp', async (req, res) => {
        await transport.handleRequest(req, res);
      });

      app.delete('/mcp', async (req, res) => {
        await transport.handleRequest(req, res);
      });
    } else {
      console.error(`Unknown MCP transport type: ${transportType}`);
      console.error(`Supported types: stdio, http`);
      process.exit(1);
    }

    await server.connect(transport);
    return;
  }
{% endmacro %}

{% macro httpModeCodeExpress(runFn, engineParam) %}
  if (cliMode === 'http') {
    // HTTP mode code using Express
    const app = express();
    app.use(express.json());

    app.post('/{{atom.doc.features.cli.http.path or atom.doc.name}}', async (req, res) => {
      try {
        const result = await {{ runFn }}(req.body{{ engineParam }});
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    const port = args['cli-port'] || args.cli_port || 3000;
    app.listen(port, () => {
      console.log(`HTTP server started on port ${port}`);
    });
    return;
  }
{% endmacro %}

{% macro defaultModeExtended() %}
  if (cliMode === 'default') {
    // Default mode code
    return await runExtended(args, { Engine });
  }
{% endmacro %}

{% macro defaultModeEngine(engineVar) %}
  if (cliMode === 'default') {
    // Default mode code
    const result = await {{ engineVar }}.run(args);

    if (typeof result !== 'undefined') {
      const stdout_format = args['stdout-format'] || args.stdout_format || null;

      if (stdout_format === 'json') console.log(JSON.stringify(result, null, 2));
      else console.log(result);
    }
    return;
  }
{% endmacro %}

{% macro runWithCatch() %}
run()
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });
{% endmacro %}

{% macro runWithThenCatch() %}
run()
  .then(() => {
    {# process.exit(0); #}
  })
  .catch((error) => {
    console.error(error.message);
    process.exit(1);
  });
{% endmacro %}

{# Main template starts here #}
import argv from '../default/input.args.js';
import { default as Engine } from '../default/{{atom.doc.features.cli_default_entry_file or atom.doc.features.main_default_entry_file}}';

{% if atom.doc.features.cli.mcp.enabled===true %}
{{ importMcpDependencies() }}
{% endif %}

{% if atom.doc.features.cli.http.enabled===true %}
// Using express for HTTP mode
import express from 'express';
{% endif %}

{% if atom.doc.features.cli.extend===true %}
  {# TYPE 1 #}
  import { default as runExtended } from '../../../cli';

  const run = async () => {
    const args = await argv();
    const cliMode = args['cli-mode'] || args.cli_mode || 'default';

    {{ defaultModeExtended() }}

    {% if atom.doc.features.cli.mcp.enabled===true %}
    {{ mcpModeCodeExtended('runExtended') }}
    {% endif %}

    {% if atom.doc.features.cli.http.enabled===true %}
    {{ httpModeCodeExpress('runExtended', ', { Engine }') }}
    {% endif %}

    console.error(`Unknown CLI mode: ${cliMode}`);
    process.exit(1);
  };

  {{ runWithThenCatch() }}
{% else %}
  {# TYPE 2 #}
  const run = async () => {
    const args = await argv();
    const cliMode = args['cli-mode'] || args.cli_mode || 'default';
    const engine = new Engine();

    {{ defaultModeEngine('engine') }}

    {% if atom.doc.features.cli.mcp.enabled===true %}
    {{ mcpModeCodeEngine('engine') }}
    {% endif %}

    {% if atom.doc.features.cli.http.enabled===true %}
    {{ httpModeCodeExpress('engine.run', '') }}
    {% endif %}

    console.error(`Unknown CLI mode: ${cliMode}`);
    process.exit(1);
  };

  {{ runWithCatch() }}
{% endif %}
{% endif %}