{% include "src/default/macros/workflow-header.js.njk" %}

{% if context.next %}
  {% if not context.next.definition.dynamic %}
    // NEXT: {{context.next.indexKey}}
    import {{context.next.codeKey}} from "./blocks/{{context.next.codeKey}}.js";
  {% endif %}
{% endif %}

export default class Workflow extends Object {

  #waitContext;

  constructor(context) {
    super(context);

    this.engine=context.engine;
  }

  async init(context) {

    {% if context.transform.params %}
      const params = context?.params;
      
      {% for param in context.transform.params %}
        {% if param.hasDefault%}
          {% if param.type ==='string'%}
            this.set('{{param.key}}',  params?.hasOwnProperty('{{param.key}}')? params['{{param.key}}']:'{{param.default}}');
          {% else %}
            this.set('{{param.key}}',  params?.hasOwnProperty('{{param.key}}')? params['{{param.key}}']:{{param.default | dump}});
          {% endif %}
        {% else %}
        this.set('{{param.key}}',this.getValue(params,'{{param.key}}'));
        {% endif %}
      {% endfor%}

      this.set('$params',params);

    {% endif %}
  }

  waitForNext(context){
    this.#waitContext=context;
    this.#waitContext?.timeoutId && clearTimeout(this.#waitContext.timeoutId) && (this.#waitContext.timeoutId=undefined);
    this.#waitContext.timeoutId = setInterval(() => {}, 0x7FFFFFFF);
  }

  async continueForNext(context){
    const next=this.#waitContext?.next;
    this.#waitContext?.timeoutId && clearTimeout(this.#waitContext.timeoutId) && (this.#waitContext.timeoutId=undefined);
    this.#waitContext=undefined;
    next && await next();
  }

  async run(context) {

    {% if workflow.parent.context.atom.doc.features.print_steps %}
      console.log(new Date().toLocaleString(),'{{indexKey}}');
    {% endif %}

    {% if definition.debugger %}
      debugger;
    {% endif %}

    {% if context.transform.sleep %}
      await sleep({{context.transform.sleep}});
    {% endif %}

    await this.init(context);

    {% if context.next %}

      {% if context.next.definition.dynamic %}
        // NEXT : {{context.next.indexKey}}
        const { default: {{context.next.codeKey}} } = await import("./blocks/{{context.next.codeKey}}.js");
      {% endif %}
      
      {# closure #}
      const c={};

      let current=new {{context.next.codeKey}}({ parent:this, engine:this.engine, flow:this, caller:c });
      let currentArgs;

      do {

        {% if workflow.parent.context.atom.doc.features.print_runners %}
          console.log(new Date().toLocaleString(),' * ', this.constructor.IndexKey,' -> ',current.constructor.IndexKey);
        {% endif %}

        const nextBlock= typeof currentArgs==='undefined'? await current.run() 
          : Array.isArray(currentArgs)? await current.run.apply(current,currentArgs) : await current.run.call(current, currentArgs) ;


        if(nextBlock?.type==='return') return nextBlock;
        else if(nextBlock?.type!=='block') break;

        if(nextBlock.toType.ParentTypeId!==this.constructor.TypeId) 
          throw new Error('Unknown situation');
        
        current=new nextBlock.toType({ parent:this, engine:this.engine, flow:this, caller:c });
        currentArgs=nextBlock.input;

      } while(true);

    {% endif %}

    
    {% if context.transform.print %}
      print({{context.transform.print | safe}});
    {% endif%}

    {% if context.transform.assert %}
      assert({{context.transform.assert | safe}});
    {% endif%}

    return this.result;
  }
}

Workflow.TypeId="{{typeId}}";
Workflow.IndexKey="{{indexKey}}";