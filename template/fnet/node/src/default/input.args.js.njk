{% if atom.doc.features.project.format === 'esm' %}
  import fnetArgs from '@fnet/args';
  import validate,{schema as inputSchema} from "./validate_input.js";

{% elif atom.doc.features.project.format === 'cjs' %}
  const fnetArgs = require('@fnet/args');
  const validate,{schema as inputSchema} = require("./validate_input.js");
{% endif %}

{% if atom.doc.features.cli.fargs and atom.doc.features.cli.fargs?.enabled !== false %}

  const get_fargs = (argv) => {
    const fargsIndex = argv.indexOf('--fargs');
    if (fargsIndex !== -1 && argv[fargsIndex + 1]) return argv[fargsIndex + 1];
    {% if atom.doc.features.cli.fargs.default %}
    else return "{{atom.doc.features.cli.fargs.default}}";
    {% endif %}
  };

  const get_ftags = (argv) => {
    const ftags = [];
    for (let i = 0; i < argv.length; i++) {
      if (argv[i] === '--ftag' && argv[i + 1]) {
        ftags.push(argv[i + 1]);
        i++;
      }
    }
    
    {% if atom.doc.features.cli.fargs.tags %}
      return ftags.length > 0 ? ftags : {{atom.doc.features.cli.fargs.tags | dump | safe}};
    {% else %}
      return ftags.length > 0 ? ftags : undefined;
    {% endif %}
  };

{% endif %}

{% if atom.doc.features.project.format === 'esm' %}

  export default async () => {

    let schema = inputSchema;
    let initial;

    {% if atom.doc.features.cli.fargs and atom.doc.features.cli.fargs?.enabled !== false %}    
    const fargs = get_fargs(process.argv.slice(2));
    const ftags = get_ftags(process.argv.slice(2));

    if (fargs) {
      const { default: fnetConfig } = await import("@fnet/config");
      const config = await fnetConfig({ name: fargs, tags: ftags });
      if (config?.data) {
        initial=config.data;
      }
    }
    {% endif %}

    const packageCallback = async () => {
      const { default: url } = await import("node:url");
      const { default: path } = await import("node:path");
      const { default: fs } = await import("node:fs");
      let currentDir = path.dirname(url.fileURLToPath(import.meta.url));
      let firstPackageJson = path.join(currentDir, "package.json");
      while (currentDir !== path.parse(currentDir).root && !fs.existsSync(firstPackageJson)) {
        currentDir = path.dirname(currentDir);
        firstPackageJson = path.join(currentDir, "package.json");
      }
      if (!fs.existsSync(firstPackageJson)) return {
        name: "Unknown",
        version: "Unknown"
      }
      else return await JSON.parse(fs.readFileSync(firstPackageJson, "utf8"));
    };

    return await fnetArgs({schema,initial,validate,packageCallback});
  };

{% elif atom.doc.features.project.format === 'cjs' %}

  module.exports = async () => {

    let schema = inputSchema;
    let initial;

    {% if atom.doc.features.cli.fargs and atom.doc.features.cli.fargs?.enabled !== false %}    
    const fargs = get_fargs(process.argv.slice(2));
    const ftags = get_ftags(process.argv.slice(2));

    if (fargs) {
      const { default: fnetConfig } = await import("@fnet/config");
      const config = await fnetConfig({ name: fargs, tags: ftags });
      if (config?.data) {
        initial=config.data;
      }
    }
    {% endif %}

    const packageCallback = async () => {
      const path = require("node:path");
      const fs = require("node:fs");

      let currentDir = __dirname;
      let firstPackageJson = path.join(currentDir, "package.json");

      while (currentDir !== path.parse(currentDir).root && !fs.existsSync(firstPackageJson)) {
        currentDir = path.dirname(currentDir);
        firstPackageJson = path.join(currentDir, "package.json");
      }

      if (!fs.existsSync(firstPackageJson)) {
        return {
          name: "Unknown",
          version: "Unknown"
        };
      } else {
        return JSON.parse(fs.readFileSync(firstPackageJson, "utf8"));
      }
    };

    return await fnetArgs({schema,initial,validate,packageCallback});
  };
{% endif %}