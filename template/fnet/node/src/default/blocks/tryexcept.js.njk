{% set assign=true %}
{% set signal=true %}
{% set resolve=true %}

{% import "src/default/types/block.js.njk" as block with context %}

{% call block.header() %}
  {% for child in childs %}
    {% if not child.definition.dynamic %}
      // CHILD: {{child.indexKey}}
      import {{child.codeKey}} from "./{{child.codeKey}}.js";
    {% endif %}
  {% endfor%}
{% endcall %}

{% call block.definition() %}
  
  try{

    {% if context.try.definition.dynamic %}
      const { default: {{context.try.codeKey}} } = await import("./{{context.try.codeKey}}.js");
    {% endif %}

    let current=new {{context.try.codeKey}}({ parent:_this, engine, flow, caller:c, error });
    let currentArgs=args;

    do {

      {% if workflow.parent.context.atom.doc.features.print_runners %}
        console.log(new Date().toLocaleString(),' * ',_this.constructor.IndexKey,' -> ',current.constructor.IndexKey);
      {% endif %}

      const nextBlock= typeof currentArgs==='undefined'? await current.run()
        : Array.isArray(currentArgs)? await current.run.apply(current,currentArgs) : await current.run(currentArgs) ;

      if(nextBlock?.type==='return') return resolve(nextBlock);
      else if(nextBlock?.type!=='block') break;

      if(nextBlock.toType.ParentTypeId!==_this.constructor.TypeId)
        return resolve(nextBlock);

      current=new nextBlock.toType({ parent:_this, engine, flow, caller:c, error });
      currentArgs=nextBlock.input;

    } while(true);            
  }
  catch(error){

    {% if context.except.definition.dynamic %}
      const { default: {{context.except.codeKey}} } = await import("./{{context.except.codeKey}}.js");
    {% endif %}

    let current=new {{context.except.codeKey}}({ parent:_this, engine, flow, caller:c , error });
    let currentArgs=args;

    do {

      {% if workflow.parent.context.atom.doc.features.print_runners %}
        console.log(new Date().toLocaleString(),' * ',_this.constructor.IndexKey,' -> ',current.constructor.IndexKey);
      {% endif %}

      const nextBlock= typeof currentArgs==='undefined'? await current.run()
        : Array.isArray(currentArgs)? await current.run.apply(current,currentArgs) : await current.run(currentArgs) ;

      if(nextBlock?.type==='return') return resolve(nextBlock);
      else if(nextBlock?.type!=='block') break;

      if(nextBlock.toType.ParentTypeId!==_this.constructor.TypeId)
        return resolve(nextBlock);

      current=new nextBlock.toType({ parent:_this, engine, flow, caller:c, error });
      currentArgs=nextBlock.input;

    } while(true);
  }

{% endcall %}

{% call block.footer()%} 
{% endcall %}