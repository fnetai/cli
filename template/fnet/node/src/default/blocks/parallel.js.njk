{% include "src/default/macros/block-header.js.njk" %}

{% include "src/default/macros/block-next-header.js.njk" %}

{% include "src/default/macros/block-modules-header.js.njk" %}

{% for child in childs %}
  {% if not child.definition.dynamic %}
    // PARALLEL CHILD: {{child.indexKey}}
    import {{child.codeKey}} from "./{{child.codeKey}}.js";
  {% endif %}
{% endfor %}

export default function Block(context) {

  {% include "src/default/macros/block-body-header.js.njk" %}

  this.run = function () {
      
    {% include "src/default/macros/block-entry-args.js.njk" %}

    return new Promise(async (resolve, reject) => {
                  
      {% include "src/default/macros/block-run-header.js.njk" %}

      {% include "src/default/macros/page.js.njk" %}

      {% include "src/default/macros/block-modules.js.njk" %}

      // PARALLEL EXECUTION
      const promises = [];

      {% for child in childs %}
        {% if child.definition.dynamic %}
          // PARALLEL CHILD: {{child.indexKey}}
          const { default: {{child.codeKey}} } = await import("./{{child.codeKey}}.js");
        {% endif %}

        promises.push((async () => {
          const current = new {{child.codeKey}}({ parent: _this, engine, flow, caller: c, onError, error });

          {% if workflow.parent.context.atom.doc.features.print_runners %}
            console.log(new Date().toLocaleString(), ' * ', _this.constructor.IndexKey, ' -> ', current.constructor.IndexKey);
          {% endif %}

          const nextBlock = Array.isArray(args)
            ? await current.run.apply(current, args)
            : await current.run.call(current, args);

          return nextBlock;
        })());
      {% endfor %}

      // Execute based on strategy
      {% set strategy = context.transform.strategy | default('all') %}
      let results;

      {% if strategy == 'race' %}
        // Promise.race - first to complete wins
        results = [await Promise.race(promises)];
      {% elif strategy == 'any' %}
        // Promise.any - first successful wins
        results = [await Promise.any(promises)];
      {% elif strategy == 'allsettled' %}
        // Promise.allSettled - all complete, collect results
        const settled = await Promise.allSettled(promises);
        results = settled.map(r => r.status === 'fulfilled' ? r.value : null);
      {% else %}
        // Promise.all - all must succeed (default)
        results = await Promise.all(promises);
      {% endif %}

      // Check if any child returned or jumped
      for (const result of results) {
        if (result?.type === 'return') {
          return resolve(result);
        }
        if (result?.type === 'block') {
          return resolve(result);
        }
      }

      {% include "src/default/macros/block-assign.js.njk" %}

      {% include "src/default/macros/block-signal.js.njk" %}

      {% if context.transform.return %}
        resolve({ type: 'return', value: {{context.transform.return | safe}} });
      {% elseif context.next %}
        {% include "src/default/macros/block-next.js.njk" %}
      {% else %}
        resolve();
      {% endif %}

      {% include "src/default/macros/block-run-footer.js.njk" %}
    });
  }

  Object.freeze(this);
}

{% include "src/default/macros/block-footer.js.njk" %}

