{% import "src/default/types/block.js.njk" as block with context %}

{% call block.header() %}
{% endcall %}

{% call block.definition() %}

  {% if context.next %}

    // NEXT : {{context.next.indexKey}}
    {% if context.next.definition.dynamic %}
      const { default: {{context.next.codeKey}} } = await import("./{{context.next.codeKey}}.js");
    {% endif %}

    let current=new {{context.next.codeKey}}({ parent:_this, engine, flow, caller:c ,onError, error });
    let currentArgs=args;

    do {

      {% if workflow.parent.context.atom.doc.features.print_runners %}
        console.log(new Date().toLocaleString(),' * ',_this.constructor.IndexKey,' -> ',current.constructor.IndexKey);
      {% endif %}

      try {
        const nextBlock= typeof currentArgs==='undefined'? await current.run()
          : Array.isArray(currentArgs)? await current.run.apply(current,currentArgs) : await current.run.call(current, currentArgs) ;

        if(nextBlock?.type==='return') return resolve(nextBlock);
        else if(nextBlock?.type!=='block') break;

        if(nextBlock.toType.ParentTypeId!==_this.constructor.TypeId)
          return resolve(nextBlock);

        current=new nextBlock.toType({ parent:_this, engine, flow, caller:c, onError, error });
        currentArgs=nextBlock.input;
      } catch (err) {
        if (onError) {
          return onError(err);
        }
        throw err;
      }

    } while(true);

  {% endif %}


  {% include "src/default/macros/block-assign.js.njk" %}

  {% include "src/default/macros/block-signal.js.njk" %}

  resolve();
  
{% endcall %}

{% call block.footer()%} 
{% endcall %}